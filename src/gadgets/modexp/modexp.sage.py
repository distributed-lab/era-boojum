

# This file was *autogenerated* from the file modexp.sage
from sage.all_cmdline import *   # import sage library

_sage_const_64 = Integer(64); _sage_const_256 = Integer(256); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_0x0423423 = Integer(0x0423423); _sage_const_0x1234123 = Integer(0x1234123); _sage_const_0x32 = Integer(0x32); _sage_const_0xFFFFFFFFFFFFFFFF = Integer(0xFFFFFFFFFFFFFFFF); _sage_const_128 = Integer(128); _sage_const_32 = Integer(32); _sage_const_4 = Integer(4)# Modexp helper file.
# Note that we use w = 64 so that n = 4. 

# Montogomery constant
N = _sage_const_64 **(_sage_const_256 )
mu = _sage_const_2 **(_sage_const_64 ) - N.inverse_mod(_sage_const_2 **(_sage_const_64 ))
print(mu)

assert _sage_const_0  <= mu < _sage_const_2 **(_sage_const_64 ), "mu is out of range"
assert (_sage_const_1  + mu * N).mod(_sage_const_2 **(_sage_const_64 )) == _sage_const_0 , "mu is incorrect"

print(f"mu = -N^(-1) mod 2^64 = 0x{mu.hex()}")

# Defining the test values
b = _sage_const_0x0423423 
e = _sage_const_0x1234123 
m = _sage_const_0x32 

def radix_64_representation(x: Integer):
    """
    Converts the given integer x to the radix-64 representation, that 
    is using 4 64-bit limbs.
    """

    c0 = (x >> _sage_const_0 ) & _sage_const_0xFFFFFFFFFFFFFFFF 
    c1 = (x >> _sage_const_64 ) & _sage_const_0xFFFFFFFFFFFFFFFF 
    c2 = (c0 >> _sage_const_128 ) | ((c1 & _sage_const_0xFFFFFFFFFFFFFFFF ) << _sage_const_32 )
    c3 = (c1 >> _sage_const_32 ) | ((c2 & _sage_const_0xFFFFFFFFFFFFFFFF ) << _sage_const_32 )

    return [c0, c1, c2, c3]

b_radix = radix_64_representation(b)
assert [b_radix[i] * _sage_const_2 **(_sage_const_64 *i) for i in range(_sage_const_4 )] == b


print(b.powermod(e, m))

